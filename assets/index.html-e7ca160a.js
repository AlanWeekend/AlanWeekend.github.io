const e=JSON.parse('{"key":"v-56deb9ae","path":"/posts/%E7%AE%97%E6%B3%95/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%9C%A8Unity%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88_Djkstra_%E6%9C%80%E5%A5%BD%E4%BC%98%E5%85%88%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/","title":"A* 寻路算法在Unity中的实现及广度优先、Djkstra、最好优先贪婪算法思想","lang":"zh-CN","frontmatter":{"title":"A* 寻路算法在Unity中的实现及广度优先、Djkstra、最好优先贪婪算法思想","date":"2022-01-10T15:00:23.000Z","categorie":["算法"],"description":"简介：搜索区域 绿色是起点A，红色是终点B，蓝色的是障碍物强。假设我们要从A点走到B点。 假设整张地图是搜索区域，那么把整张地图划分为方块状的网格，这样便简化了搜索区域，如此便能用二维数组来表示整张地图。而每一个网格分有可行走和不可行走两个状态。通过从A到B走那些网格来确定路径。 开始搜索 上一步我们将地图简化为可管理的二维数组，下一步就是搜索最短路径。搜索方法有点类似与八连通种子填充算法。做法是从A点开始，检查八连通的网格，以此递归向外搜索直到找到目标。 搜索的步骤如下： 创建两个列表，一个是“打开列表”用于存放将要进行搜索，但还没搜索过的网格。另一个是“关闭列表”用于存放已经搜索过的网格。 从起点A开始，将其添加到要进行搜索的“打开列表中”。 查看起点附近八连通的所有可行走的网格，这里要忽略掉添加到“关闭列表”中的网格，已经搜索过的网格不必再次搜索，并且将这些网格的父网格设置A，然后将这些网格添加到“打开列表”中。 从“打开列表”中删除起始网格A，并将其添加到“关闭列表中”。","head":[["meta",{"property":"og:url","content":"https://alanweekend.github.io/posts/%E7%AE%97%E6%B3%95/A%E6%98%9F%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%9C%A8Unity%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88_Djkstra_%E6%9C%80%E5%A5%BD%E4%BC%98%E5%85%88%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"}],["meta",{"property":"og:site_name","content":"Gaming & Coding"}],["meta",{"property":"og:title","content":"A* 寻路算法在Unity中的实现及广度优先、Djkstra、最好优先贪婪算法思想"}],["meta",{"property":"og:description","content":"简介：搜索区域 绿色是起点A，红色是终点B，蓝色的是障碍物强。假设我们要从A点走到B点。 假设整张地图是搜索区域，那么把整张地图划分为方块状的网格，这样便简化了搜索区域，如此便能用二维数组来表示整张地图。而每一个网格分有可行走和不可行走两个状态。通过从A到B走那些网格来确定路径。 开始搜索 上一步我们将地图简化为可管理的二维数组，下一步就是搜索最短路径。搜索方法有点类似与八连通种子填充算法。做法是从A点开始，检查八连通的网格，以此递归向外搜索直到找到目标。 搜索的步骤如下： 创建两个列表，一个是“打开列表”用于存放将要进行搜索，但还没搜索过的网格。另一个是“关闭列表”用于存放已经搜索过的网格。 从起点A开始，将其添加到要进行搜索的“打开列表中”。 查看起点附近八连通的所有可行走的网格，这里要忽略掉添加到“关闭列表”中的网格，已经搜索过的网格不必再次搜索，并且将这些网格的父网格设置A，然后将这些网格添加到“打开列表”中。 从“打开列表”中删除起始网格A，并将其添加到“关闭列表中”。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://alanweekend.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-05-30T07:00:52.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"A* 寻路算法在Unity中的实现及广度优先、Djkstra、最好优先贪婪算法思想"}],["meta",{"property":"article:author","content":"Weekend"}],["meta",{"property":"article:published_time","content":"2022-01-10T15:00:23.000Z"}],["meta",{"property":"article:modified_time","content":"2023-05-30T07:00:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"A* 寻路算法在Unity中的实现及广度优先、Djkstra、最好优先贪婪算法思想\\",\\"image\\":[\\"https://alanweekend.github.io/\\"],\\"datePublished\\":\\"2022-01-10T15:00:23.000Z\\",\\"dateModified\\":\\"2023-05-30T07:00:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Weekend\\",\\"url\\":\\"https://alanweekend.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"简介：搜索区域","slug":"简介-搜索区域","link":"#简介-搜索区域","children":[]},{"level":2,"title":"开始搜索","slug":"开始搜索","link":"#开始搜索","children":[]},{"level":2,"title":"路径评分","slug":"路径评分","link":"#路径评分","children":[]},{"level":2,"title":"继续搜索","slug":"继续搜索","link":"#继续搜索","children":[]},{"level":2,"title":"步骤摘要","slug":"步骤摘要","link":"#步骤摘要","children":[]},{"level":2,"title":"广度优先算法","slug":"广度优先算法","link":"#广度优先算法","children":[]},{"level":2,"title":"Dijkstra算法","slug":"dijkstra算法","link":"#dijkstra算法","children":[]},{"level":2,"title":"Greed-Best-First-Search","slug":"greed-best-first-search","link":"#greed-best-first-search","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[{"level":3,"title":"四种算法的选择","slug":"四种算法的选择","link":"#四种算法的选择","children":[]}]},{"level":2,"title":"A*算法实现","slug":"a-算法实现","link":"#a-算法实现","children":[]}],"git":{"createdTime":1685430052000,"updatedTime":1685430052000,"contributors":[{"name":"Weekend","email":"872285171@qq.com","commits":1}]},"readingTime":{"minutes":10.36,"words":3108},"filePathRelative":"posts/算法/A星寻路算法在Unity中的实现及广度优先_Djkstra_最好优先贪婪算法思想/index.md","localizedDate":"2022年1月10日","excerpt":"<h2> 简介：搜索区域</h2>\\n<p>绿色是起点A，红色是终点B，蓝色的是障碍物强。假设我们要从A点走到B点。\\n</p>\\n<p>假设整张地图是搜索区域，那么把整张地图划分为方块状的网格，这样便简化了搜索区域，如此便能用二维数组来表示整张地图。而每一个网格分有可行走和不可行走两个状态。通过从A到B走那些网格来确定路径。</p>\\n<h2> 开始搜索</h2>\\n<p>上一步我们将地图简化为可管理的二维数组，下一步就是搜索最短路径。搜索方法有点类似与八连通种子填充算法。做法是从A点开始，检查八连通的网格，以此递归向外搜索直到找到目标。</p>\\n<p>搜索的步骤如下：</p>\\n<ol>\\n<li>创建两个列表，一个是“打开列表”用于存放将要进行搜索，但还没搜索过的网格。另一个是“关闭列表”用于存放已经搜索过的网格。</li>\\n<li>从起点A开始，将其添加到要进行搜索的“打开列表中”。</li>\\n<li>查看起点附近八连通的所有可行走的网格，这里要忽略掉添加到“关闭列表”中的网格，已经搜索过的网格不必再次搜索，并且将这些网格的父网格设置A，然后将这些网格添加到“打开列表”中。</li>\\n<li>从“打开列表”中删除起始网格A，并将其添加到“关闭列表中”。</li>\\n</ol>","copyright":{"author":"Weekend","license":"MIT"},"autoDesc":true}');export{e as data};
